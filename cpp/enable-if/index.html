<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>
      EnableIf in C++11 &bull; Lounge&lt;C++&gt;
    </title>
    <link href="../../assets/css/all-e506c42a.css" rel="stylesheet" type="text/css" />
    <script src="../../assets/js/all-da39a3ee.js" type="text/javascript"></script>
    <link href="//assets.loungecpp.net/img/favicon.png" rel="icon" type="image/png" />
  </head>
  <body class='cpp cpp_enable-if cpp_enable-if_index'>
    <div class='page-container'>
      <header class='page-header'>
        <img alt='Lounge&lt;C++&gt;' class='page-header-logo' src='//assets.loungecpp.net/img/logo.png'>
        <h1 class='page-header-title'>
          <a href='/'>Lounge&lt;C++&gt;</a>
        </h1>
        <p>
          Less temporary, but somehow still temporary <img alt=":iiam:" src="//assets.loungecpp.net/img/emote/emot-iiam.gif" />
        </p>
      </header>
      
      <p><table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Table of Contents</h2></div><ul><ul><li><a href="#Template_parameter_lists">Template parameter lists</a></li><li><a href="#Template_aliases">Template aliases</a></li><li><a href="#Variadic_templates">Variadic templates</a></li><li><a href="#Nontype_parameters">Non-type parameters</a></li><li><a href="#No_dummies">No dummies</a></li></ul></ul></td></tr></table>
      </p>
      <p>In C++03 one could use SFINAE to enable or disable overloads based on a boolean condition with a simple metafunction that usually went by the name <code>enable_if</code>. C++11 now standardised this metafunction. In C++03 one could use this in a number of places, common ones being return types, or extra defaulted parameters:
      </p>
      <pre>template &lt;typename T&gt;
      typename enable_if&lt;std::is_polymorphic&lt;T&gt;::value, int&gt;::type // hard-to-read return type
      f(T t);
      
      template &lt;typename T&gt;
      some_ctor(T t, typename enable_if&lt;std::is_polymorphic&lt;T&gt;::value&gt;::type* = 0);
      </pre>
      
      <p>In C++11 using this can be a lot less clunky.
      </p>
      
      <h2><span class="editsection">&#91;<a href="?section=Template_parameter_lists" title="Edit section: Template parameter lists">edit</a>&#93;</span> <a name="Template_parameter_lists"></a><span class="mw-headline" id="Template_parameter_lists">Template parameter lists</span></h2>
      
      
      
      <p>C++11 extends SFINAE to template parameter lists, allowing us to stop uglifying return types, or adding function parameters.
      </p>
      <pre>template &lt;typename T
              , typename = typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value&gt;::type // SFINAE here
              &gt;
      int f(T t); // signature is not butchered
      
      template &lt;typename T
              , typename = typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value&gt;::type // SFINAE here
              &gt;
      some_ctor(T t); // signature is not butchered
      </pre>
      
      
      <h2><span class="editsection">&#91;<a href="?section=Template_aliases" title="Edit section: Template aliases">edit</a>&#93;</span> <a name="Template_aliases"></a><span class="mw-headline" id="Template_aliases">Template aliases</span></h2>
      
      
      
      <p>We can still improve, starting by using <a href="Reducing pain with template aliases">template aliases</a>:
      </p>
      <pre>template &lt;typename Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;Condition::value&gt;&gt;; // Invoke is from the page linked above
      
      template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              &gt;
      int f(T t);
      </pre>
      
      <p>No care needs to be given to the second parameter of <code>std&#58;&#58;enable_if</code>, because it won't be used anyway in this place.
      </p>
      
      <h2><span class="editsection">&#91;<a href="?section=Variadic_templates" title="Edit section: Variadic templates">edit</a>&#93;</span> <a name="Variadic_templates"></a><span class="mw-headline" id="Variadic_templates">Variadic templates</span></h2>
      
      
      
      <p>What if there's more than one condition? One could add an extra parameter or one could make <code>EnableIf</code> variadic:
      </p>
      <pre>// Logical conjunction metafunction
      template &lt;typename... T&gt;
      struct All : std::true_type {};
      template &lt;typename Head, typename... Tail&gt;
      struct All&lt;Head, Tail...&gt; : Conditional&lt;Head, All&lt;Tail...&gt;, std::false_type&gt; {};
      
      template &lt;typename... Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;All&lt;Condition...&gt;&gt;;
      
      template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;, std::is_empty&lt;T&gt;&gt;
              &gt;
      int f(T t);
      </pre>
      
      <p>See <a href="http://loungecpp.net/w/Reducing_pain_with_template_aliases" target="_blank">here</a> for <code>Conditional</code>.
      </p>
      
      <h2><span class="editsection">&#91;<a href="?section=Nontype_parameters" title="Edit section: Non-type parameters">edit</a>&#93;</span> <a name="Nontype_parameters"></a><span class="mw-headline" id="Nontype_parameters">Non-type parameters</span></h2>
      
      
      
      <p>What we have sure looks nice now. However, this still has problems (which exist in the previous versions too).
      </p>
      <p><pre>template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              &gt;
      int f(T t);
      template &lt;typename T
              , typename = DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt; // DisableIf left as an exercise to the reader :P
              &gt;
      int f(T t); // Ooops, redeclaration of same template with different default arguments
      </pre>
      </p>
      <p>This fails even before substitution. The compiler rejects the code because it essentially declares the same template twice (<code>template &lt;typename T, typename&gt; int f(int)</code> with different default arguments. This can be solved by making the templates actually be different templates. Just add a dummy parameter to one:
      </p>
      <p><pre>template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              &gt;
      int f(T t);
      template &lt;typename T
              , typename = DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              , typename = void // dummy to make the functions different templates
              &gt;
      int f(T t);
      </pre>
      </p>
      <p>This solution is not pretty, and most importantly, it's not scalable: if you have more overloads, you need more dummies to distinguish them all.
      </p>
      <p>An alternative way of fixing this is by tweaking the SFINAEing parameter and our <code>EnableIf</code> alias slightly:
      </p>
      <pre>enum class enabled { _ }; // just a type that can be used as a template parameter and is as inocuous as possible
      constexpr auto _ = enabled::_; // shortcut for dummy value (do not place _ in global scope!)
      template &lt;typename... Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;All&lt;Condition...&gt;, enabled&gt;&gt;; // now EnableIf&lt;...&gt; isn't void, but enabled
      
      template &lt;typename T
              , EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt; = _ // default to the dummy value
              &gt;
      int f(T t);
      template &lt;typename T
              , DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt; = _
              &gt;
      int f(T t);
      </pre>
      
      <p>Now the templates are not the same, because one of them won't even be considered: the type of the second template parameter is resolved with substitution, and <i>Substitution Failure Is Not An Error</i>!
      </p>
      
      <h2><span class="editsection">&#91;<a href="?section=No_dummies" title="Edit section: No dummies">edit</a>&#93;</span> <a name="No_dummies"></a><span class="mw-headline" id="No_dummies">No dummies</span></h2>
      
      
      
      <p>One can get rid of the dummy by making the SFINAEing template parameter a template parameter pack instead.
      </p>
      <pre>enum class enabled {}; // no value necessary
      template &lt;typename... Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;All&lt;Condition...&gt;, enabled&gt;&gt;; // same as before
      
      template &lt;typename T
              , EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;... // no defaults needed: pack will be empty
              &gt;
      int f(T t);
      template &lt;typename T
              , DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt;...
              &gt;
      int f(T t);
      </pre>
      
      <p>The pack will be deduced as empty, but since substitution still has to occur we still get SFINAE. Unfortunately, it seems versions of GCC and clang as of this writing still have trouble dealing with this form.
      </p>
      <footer class='page-footer'>
        <p>
          Content on Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported unless noted otherwise.
          Uses Google Analytics which sets a tracking cookie for statistical purposes (see <a href="https://www.google.com/analytics/learn/privacy.html">GA privacy policy</a>).
        </p>
        <p>
          Source lives in a <a href="https://github.com/LoungeCPP/loungecpp.net">GitHub repository</a> and is powered
          by <a href="http://middlemanapp.com/">Middleman</a>. Open a PR if you want to change anything.
        </p>
      </footer>
    </div>
    <script defer src='//www.google-analytics.com/analytics.js'></script>
    <script src="../../assets/js/analytics-0a593893.js" type="text/javascript" defer="defer"></script>
  </body>
</html>
