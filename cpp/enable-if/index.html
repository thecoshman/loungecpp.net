<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>
      EnableIf in C++11 &bull; Lounge&lt;C++&gt;
    </title>
    <link href="../../assets/css/all-89eed68e.css" rel="stylesheet" type="text/css" />
    <script src="../../assets/js/all-da39a3ee.js" type="text/javascript"></script>
    <link href="../../favicon.png" rel="icon" type="image/png" />
  </head>
  <body class='cpp cpp_enable-if cpp_enable-if_index'>
    <div class='page-container'>
      <header class='page-header'>
        <img alt='Lounge&lt;C++&gt;' class='page-header-logo' src='/assets/img/logo-89fbe1a2.png'>
        <h1 class='page-header-title'>
          <a href='/'>Lounge&lt;C++&gt;</a>
        </h1>
      </header>
      <p>In C++03 one could use SFINAE to enable or disable overloads based on a boolean condition with a simple
      metafunction that usually went by the name <code>enable_if</code>. C++11 now standardised this metafunction.
      In C++03 one could use this in a number of places, common ones being return types, or extra defaulted parameters:</p>
      
      <pre><code>template &lt;typename T&gt;
      typename enable_if&lt;std::is_polymorphic&lt;T&gt;::value, int&gt;::type // hard-to-read return type
      f(T t);
      
      template &lt;typename T&gt;
      some_ctor(T t, typename enable_if&lt;std::is_polymorphic&lt;T&gt;::value&gt;::type* = 0);
      </code></pre>
      
      <p>In C++11 using this can be a lot less clunky.</p>
      
      <h2>Template parameter lists</h2>
      
      <p>C++11 extends SFINAE to template parameter lists, allowing us to stop uglifying return types, or adding function parameters.</p>
      
      <pre><code>template &lt;typename T
              , typename = typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value&gt;::type // SFINAE here
              &gt;
      int f(T t); // signature is not butchered
      
      template &lt;typename T
              , typename = typename std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value&gt;::type // SFINAE here
              &gt;
      some_ctor(T t); // signature is not butchered
      </code></pre>
      
      <h2>Template aliases</h2>
      
      <p>We can still improve, starting by using <a href="/cpp/reducing-pain-with-aliases">template aliases</a>:</p>
      
      <pre><code>template &lt;typename Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;Condition::value&gt;&gt;; // Invoke is from the page linked above
      
      template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              &gt;
      int f(T t);
      </code></pre>
      
      <p>No care needs to be given to the second parameter of <code>std::enable_if</code>, because it won&#39;t be used anyway in this place.</p>
      
      <h2>Variadic templates</h2>
      
      <p>What if there&#39;s more than one condition? One could add an extra parameter or one could make <code>EnableIf</code> variadic:</p>
      
      <pre><code>// Logical conjunction metafunction
      template &lt;typename... T&gt;
      struct All : std::true_type {};
      template &lt;typename Head, typename... Tail&gt;
      struct All&lt;Head, Tail...&gt; : Conditional&lt;Head, All&lt;Tail...&gt;, std::false_type&gt; {};
      
      template &lt;typename... Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;All&lt;Condition...&gt;&gt;;
      
      template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;, std::is_empty&lt;T&gt;&gt;
              &gt;
      int f(T t);
      </code></pre>
      
      <p>See <a href="/cpp/reducing-pain-with-aliases">template aliases</a> for <code>Conditional</code>.</p>
      
      <h2>Non-type parameters</h2>
      
      <p>What we have sure looks nice now. However, this still has problems (which exist in the previous versions too).</p>
      
      <pre><code>template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              &gt;
      int f(T t);
      template &lt;typename T
              , typename = DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt; // DisableIf left as an exercise to the reader :P
              &gt;
      int f(T t); // Ooops, redeclaration of same template with different default arguments
      </code></pre>
      
      <p>This fails even before substitution. The compiler rejects the code because it essentially declares the same template
      twice (<code>template &lt;typename T, typename&gt; int f(int)</code> with different default arguments. This can be solved by making
      the templates actually be different templates. Just add a dummy parameter to one:</p>
      
      <pre><code>template &lt;typename T
              , typename = EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              &gt;
      int f(T t);
      template &lt;typename T
              , typename = DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt;
              , typename = void // dummy to make the functions different templates
              &gt;
      int f(T t);
      </code></pre>
      
      <p>This solution is not pretty, and most importantly, it&#39;s not scalable: if you have more overloads, you need more dummies to distinguish them all.</p>
      
      <p>An alternative way of fixing this is by tweaking the SFINAEing parameter and our <code>EnableIf</code> alias slightly:</p>
      
      <pre><code>enum class enabled { _ }; // just a type that can be used as a template parameter and is as inocuous as possible
      constexpr auto _ = enabled::_; // shortcut for dummy value (do not place _ in global scope!)
      template &lt;typename... Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;All&lt;Condition...&gt;, enabled&gt;&gt;; // now EnableIf&lt;...&gt; isn&#39;t void, but enabled
      
      template &lt;typename T
              , EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt; = _ // default to the dummy value
              &gt;
      int f(T t);
      template &lt;typename T
              , DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt; = _
              &gt;
      int f(T t);
      </code></pre>
      
      <p>Now the templates are not the same, because one of them won&#39;t even be considered: the type of the second template
      parameter is resolved with substitution, and <em>Substitution Failure Is Not An Error</em>!</p>
      
      <h2>No dummies</h2>
      
      <p>One can get rid of the dummy by making the SFINAEing template parameter a template parameter pack instead.</p>
      
      <pre><code>enum class enabled {}; // no value necessary
      template &lt;typename... Condition&gt;
      using EnableIf = Invoke&lt;std::enable_if&lt;All&lt;Condition...&gt;, enabled&gt;&gt;; // same as before
      
      template &lt;typename T
              , EnableIf&lt;std::is_polymorphic&lt;T&gt;&gt;... // no defaults needed: pack will be empty
              &gt;
      int f(T t);
      template &lt;typename T
              , DisableIf&lt;std::is_polymorphic&lt;T&gt;&gt;...
              &gt;
      int f(T t);
      </code></pre>
      
      <p>The pack will be deduced as empty, but since substitution still has to occur we still get SFINAE.
      Unfortunately, it seems versions of GCC and clang as of this writing still have trouble dealing with this form.</p>
      <footer class='page-footer'>
        <p>
          Content on Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported unless noted otherwise.
          Uses Google Analytics which sets a tracking cookie for statistical purposes (see <a href="https://www.google.com/analytics/learn/privacy.html">GA privacy policy</a>).
        </p>
        <p>
          Source lives in a <a href="https://github.com/LoungeCPP/loungecpp.net">GitHub repository</a> and is powered
          by <a href="http://middlemanapp.com/">Middleman</a>. Open a PR if you want to change anything.
        </p>
      </footer>
    </div>
    <script defer src='//www.google-analytics.com/analytics.js'></script>
    <script src="../../assets/js/analytics-0a593893.js" type="text/javascript" defer="defer"></script>
  </body>
</html>
