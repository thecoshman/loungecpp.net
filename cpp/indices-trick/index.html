<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>
      The indices trick &bull; Lounge&lt;C++&gt;
    </title>
    <link href="../../assets/css/all-e506c42a.css" rel="stylesheet" type="text/css" />
    <script src="../../assets/js/all-da39a3ee.js" type="text/javascript"></script>
    <link href="//assets.loungecpp.net/img/favicon.png" rel="icon" type="image/png" />
  </head>
  <body class='cpp cpp_indices-trick cpp_indices-trick_index'>
    <div class='page-container'>
      <header class='page-header'>
        <img alt='Lounge&lt;C++&gt;' class='page-header-logo' src='//assets.loungecpp.net/img/logo.png'>
        <h1 class='page-header-title'>
          <a href='/'>Lounge&lt;C++&gt;</a>
        </h1>
        <p>
          Less temporary, but somehow still temporary <img alt=":iiam:" src="//assets.loungecpp.net/img/emote/emot-iiam.gif" />
        </p>
      </header>
      
      <p>You have a tuple and you want to expand it as if it was a parameter pack. How do you solve that?
      </p>
      <p>The indices trick basically amounts to tag dispatching to a structure that encodes all the indices.
      Such a structure can be as simple as this:
      </p>
      <p><pre>template &lt;std::size_t... Indices&gt;
      struct indices {};
      </pre>
      </p>
      <p>Then we use a single tagged overload that uses type deduction to extract the parameters of <code>indices</code> as a pack:
      </p>
      <p><pre>template &lt;Tuple, std::size_t... Indices&gt;
      std::array&lt;int, std::tuple_size&lt;Tuple&gt;::value&gt; f_them_all(Tuple&& t, indices&lt;Indices...&gt;) {
          return std::array&lt;int, std::tuple_size&lt;Tuple&gt;::value&gt; { { f(std::get&lt;Indices&gt;(std::forward&lt;Tuple&gt;(t)))... } }; 
      }
      </pre>
      </p>
      <p>Now all that's left is a way to build a pack of indices. Not that complicated.
      </p>
      <pre>template &lt;std::size_t... Is&gt;
      struct indices {};
      
      template &lt;std::size_t N, std::size_t... Is&gt;
      struct build_indices
          : build_indices&lt;N-1, N-1, Is...&gt; {};
      
      template &lt;std::size_t... Is&gt;
      struct build_indices&lt;0, Is...&gt; : indices&lt;Is...&gt; {};
      
      template &lt;typename Tuple&gt;
      using IndicesFor = build_indices&lt;std::tuple_size&lt;Bare&lt;Tuple&gt;&gt;::value&gt;;
      </pre>
      
      <p>And the overload that builds the tag and dispatches:
      </p>
      <p><pre>template &lt;typename Tuple&gt;
      std::array&lt;int, std::tuple_size&lt;Tuple&gt;::value&gt; f_them_all(Tuple&& t) {
          return f_them_all(std::forward&lt;Tuple&gt;(t), IndicesFor&lt;Tuple&gt; {});
      }
      </pre>
      </p>
      <footer class='page-footer'>
        <p>
          Content on Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported unless noted otherwise.
          Uses Google Analytics which sets a tracking cookie for statistical purposes (see <a href="https://www.google.com/analytics/learn/privacy.html">GA privacy policy</a>).
        </p>
        <p>
          Source lives in a <a href="https://github.com/LoungeCPP/loungecpp.net">GitHub repository</a> and is powered
          by <a href="http://middlemanapp.com/">Middleman</a>. Open a PR if you want to change anything.
        </p>
      </footer>
    </div>
    <script defer src='//www.google-analytics.com/analytics.js'></script>
    <script src="../../assets/js/analytics-0a593893.js" type="text/javascript" defer="defer"></script>
  </body>
</html>
